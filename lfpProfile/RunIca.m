
function [ica] = RunIca(varargin)
% [ica] = RunIca(varargin)
%
% Perform Independent Component Analysis (ICA) decomposition of input data 
% using the logistic infomax ICA algorithm of Bell & Sejnowski (1995) with 
% the natural gradient feature of Amari, Cichocki & Yang. 
%
% INPUTS
% <optional>
% basepath      Default pwd 
% lfp           a buzcode structure with fields lfp.data,
%                                                   lfp.timestamps
%                                                   lfp.samplingRate
%                                                   lfp.channels.
%               If not provided, runs bz_getLFP('all') on basepath 
%               IMPORTANT: lfp provided must be in the correct order of
%               channels! If not provided, this function will by default
%               load the channels in the correct order from the first
%               shank.
% shankNum      Specifies which shank to load channels from if lfp is not provided.
%               Default 1
% passband      Prefiltering passband interval, default [30 200]
% nICs          Number of independent components to extract. Default 8.
% saveMat       Save results, default true.
% force         Force analysis (disable loading option if already computed, 
%                   default false)
% plotWeights   Default true
% plotCFC       Will also calculate CFC for ica outputs for easier
%               assignment. Default true.
% regionChan    Optional, if a .hippocampalLayers.channelinfo.mat file
%               exists, or if input is provided, it will label these
%               channels on the ica output. Default order is or, pyr, rad,
%               slm
% chanRange     Optional. Specify whether you only want a subset of
%               channels from the shank to be used. 
%
% TO DO: INCLUDE IMPORTANTS IMPUTS TO runica.mat as additional arguments!
% 
% OUTPUT
% ica           a buzcode structure with the following fields:
% .activations  independent components (this is the data matrix to use for
%               analysis)
% .data         independent components organized by explanatory variance.
% .timestamps
% .topo         Weight matrix (as generated by FieldTrip)
% .sphere       data sphering matrix (chans,chans)
% .weights      ICA weight matrix (comps,chans)
% .meanvar      Explained variance.
%
% Manu Valero 2020
% Edit by IZ April 2021
% This functions is a buzcode wrapper for the function 'runica.mat' from Scott
% Makeig (CNL/The Salk Institute, La Jolla, 1996-)
% Copyright (C) 2004-2011 by 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Parse options
p = inputParser;
addParameter(p,'basepath',pwd,@ischar);
addParameter(p,'lfp',[],@isstruct);
addParameter(p,'shankNum',1,@isnumeric)
addParameter(p,'saveMat',true,@islogical);
addParameter(p,'force',true,@islogical);
addParameter(p,'passband',[30 200],@isnumeric)
addParameter(p,'nICs',15,@isnumeric)
addParameter(p,'plotWeights',true,@islogical)
addParameter(p,'plotCFC',true,@islogical)
addParameter(p,'regionChan',[],@isnumeric)
addParameter(p,'chanRange',[], @isnumeric)

parse(p,varargin{:});
basepath = p.Results.basepath;
lfp = p.Results.lfp;
saveMat = p.Results.saveMat;
force = p.Results.force;
passband = p.Results.passband;
nICs = p.Results.nICs;
shankNum = p.Results.shankNum;
regionChan = p.Results.regionChan;
plotWeights = p.Results.plotWeights;
plotCFC = p.Results.plotCFC;
chanRange = p.Results.chanRange;

% Deal with inputs
prevBasepath = pwd;
cd(basepath);

targetFile = dir('*.ica.channelInfo.mat');
if ~isempty(targetFile) && ~force
    disp('ICA already computed! Loading file.');
    load(targetFile.name);
    return
end

if isempty(lfp)
    try 
        sessionInfo = bz_getSessionInfo(basepath, 'noPrompts', true);
        if isempty(chanRange)
            channelOrder = sessionInfo.AnatGrps(shankNum).Channels; 
        else
            channelOrder = sessionInfo.AnatGrps(shankNum).Channels(chanRange); 
        end
        lfp = bz_GetLFP(channelOrder);
    catch
        error('LFP not found!');
    end
end

if isempty(regionChan)
    regFile = dir('*.hippocampalLayers.channelinfo.mat');
    if ~isempty(regFile)
        load(regFile.name);
        regionChan = hippocampalLayers.all;
    end
end

% Filtering (Schomburg et al, 2014)
disp('Filtering...');
lfpFilt = bz_Filter(lfp,'passband',passband,'order',4,'filter','butter');


% Run runica
[weights,sphere,meanvar,bias,signs,lrates,data] = runica(double(lfpFilt.data'),'lrate',1.0000e-03,'pca',nICs);

% Processing adapted from FieldTrip
% Normalize sphere
sphere = sphere./norm(sphere);
% Generate mixing and unmixing matrix
unmixing = weights*sphere;
if (size(unmixing,1)==size(unmixing,2)) && rank(unmixing)==size(unmixing,1)
    mixing = inv(unmixing);
else
    mixing = pinv(unmixing);
end
activations = unmixing * lfpFilt.data';

% Populate the structure
ica.activations = activations;
ica.data = data';
ica.timestamps = lfp.timestamps;
ica.sphere = sphere;
ica.weights = weights;
ica.meanvar = meanvar;
ica.topo = mixing;
ica.unmixing = unmixing;
ica.samplingRate = lfp.samplingRate;
ica.channels = lfp.channels;

if saveMat
    disp('Saving results...');
    filename = split(pwd,filesep); filename = filename{end};
    save([filename '.ica.channelInfo.mat'],'ica','-v7.3');
end

if plotWeights
    figure;
    plot(ica.topo,repmat([1:numel(ica.channels)]',1,nICs),'LineWidth',2);
    set(gca,'YDir','reverse')
    hold on
    legend
    ylim([1 size(ica.weights,2)])
    if ~isempty(regionChan)
        for ii = 1:length(regionChan)
            idx = find(ica.channels == regionChan(ii));
            if ~isempty(idx)
                line([-300 300],[idx idx],'Color',[0.5 0.5 0.5],'LineStyle','--');
            end
        end 
    end
    if ~isfolder('ICA')
        mkdir('ICA')
    end
    saveas(gcf,'ICA\Weights.png');
end

if plotCFC
    if exist('hippocampalLayers','var')
        pyrCh = hippocampalLayers.pyramidal;
    else 
        %Pick the middle channel from the shank for LFP
        pyrCh = channelOrder(floor(length(channelOrder)/2));
    end
    lfpTheta = bz_GetLFP(pyrCh);

    %% For each ICA, run CFC
    phaserange=5:0.5:12; 
    amprange=30:10:200;
    % Make lfp structure, with first channel as the Pyr lfp, and remaining
    % channels as the ica components. 
    lfpICA = lfpTheta;
    % Only take 1000 seconds worth of data to keep the computation quick
    lfpICA.timestamps = lfpICA.timestamps(500:1500*1250,1);
    lfpICA.data = double(lfpICA.data(500:1500*1250,1));
    lfpICA.data(:,2:(size(ica.weights,1)+1)) = ica.activations(:,500:1500*1250)';
    lfpICA.channels = 1:1:(size(ica.weights,1)+1);
    [comodulogram] = bz_CFCPhaseAmp(lfpICA,phaserange,amprange,'phaseCh',1,'ampCh',2:length(lfpICA.channels));
    
    set(gcf,'Position',[100 100 1400 300])  
    saveas(gcf,'ICA\CFC.png');
end

cd(prevBasepath);
end